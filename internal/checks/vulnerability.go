package checks

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type VulnerabilityCheck struct{}

func (c VulnerabilityCheck) ID() string {
	return "vulnerability"
}

func (c VulnerabilityCheck) Title() string {
	return "No known vulnerabilities in dependencies"
}

func (c VulnerabilityCheck) Run(ctx Context) (CheckResult, error) {
	stack := ctx.Config.Stack

	// Determine which audit command to run based on stack and files present
	auditCmd, auditArgs, toolName := c.getAuditCommand(ctx.RootDir, stack)

	if auditCmd == "" {
		return CheckResult{
			ID:       c.ID(),
			Title:    c.Title(),
			Severity: SeverityInfo,
			Passed:   true,
			Message:  "No supported package manager detected for vulnerability scanning",
		}, nil
	}

	// Check if the audit tool is available
	if _, err := exec.LookPath(auditCmd); err != nil {
		return CheckResult{
			ID:       c.ID(),
			Title:    c.Title(),
			Severity: SeverityInfo,
			Passed:   true,
			Message:  toolName + " not installed, skipping vulnerability check",
			Suggestions: []string{
				c.getInstallSuggestion(auditCmd),
			},
		}, nil
	}

	// Run the audit command
	cmd := exec.Command(auditCmd, auditArgs...)
	cmd.Dir = ctx.RootDir
	output, err := cmd.CombinedOutput()

	// Parse the result
	return c.parseResult(err, string(output), toolName)
}

func (c VulnerabilityCheck) getAuditCommand(rootDir, stack string) (string, []string, string) {
	// Check for Ruby/Bundler (Gemfile.lock)
	if fileExists(rootDir, "Gemfile.lock") {
		return "bundle", []string{"audit", "check", "--update"}, "bundle-audit"
	}

	// Check for Node.js (package-lock.json or yarn.lock)
	if fileExists(rootDir, "yarn.lock") {
		return "yarn", []string{"audit", "--summary"}, "yarn audit"
	}
	if fileExists(rootDir, "package-lock.json") {
		return "npm", []string{"audit", "--audit-level=moderate"}, "npm audit"
	}

	// Check for PHP/Composer (composer.lock)
	if fileExists(rootDir, "composer.lock") {
		return "composer", []string{"audit"}, "composer audit"
	}

	// Check for Python (requirements.txt or Pipfile.lock)
	if fileExists(rootDir, "Pipfile.lock") || fileExists(rootDir, "requirements.txt") {
		// pip-audit is the recommended tool
		return "pip-audit", []string{}, "pip-audit"
	}

	// Check for Go (go.sum)
	if fileExists(rootDir, "go.sum") {
		return "govulncheck", []string{"./..."}, "govulncheck"
	}

	// Check for Rust (Cargo.lock)
	if fileExists(rootDir, "Cargo.lock") {
		return "cargo", []string{"audit"}, "cargo-audit"
	}

	return "", nil, ""
}

func (c VulnerabilityCheck) getInstallSuggestion(cmd string) string {
	suggestions := map[string]string{
		"bundle":     "Install bundle-audit: gem install bundler-audit",
		"npm":        "npm is usually included with Node.js",
		"yarn":       "Install yarn: npm install -g yarn",
		"composer":   "composer audit requires Composer 2.4+",
		"pip-audit":  "Install pip-audit: pip install pip-audit",
		"govulncheck": "Install govulncheck: go install golang.org/x/vuln/cmd/govulncheck@latest",
		"cargo":      "Install cargo-audit: cargo install cargo-audit",
	}
	if suggestion, ok := suggestions[cmd]; ok {
		return suggestion
	}
	return "Install " + cmd
}

func (c VulnerabilityCheck) parseResult(err error, output, toolName string) (CheckResult, error) {
	outputLower := strings.ToLower(output)

	// Check for common vulnerability indicators
	hasVulnerabilities := err != nil &&
		(strings.Contains(outputLower, "vulnerabilit") ||
			strings.Contains(outputLower, "insecure") ||
			strings.Contains(outputLower, "critical") ||
			strings.Contains(outputLower, "high") ||
			strings.Contains(outputLower, "moderate") ||
			strings.Contains(outputLower, "advisory"))

	// Special case: npm audit returns exit code 1 even for info-level issues
	if strings.Contains(toolName, "npm") && err != nil {
		// Check if there are actual vulnerabilities vs just warnings
		if !strings.Contains(outputLower, "critical") &&
			!strings.Contains(outputLower, "high") &&
			!strings.Contains(outputLower, "moderate") {
			hasVulnerabilities = false
		}
	}

	// No vulnerabilities found
	if !hasVulnerabilities && err == nil {
		return CheckResult{
			ID:       c.ID(),
			Title:    c.Title(),
			Severity: SeverityInfo,
			Passed:   true,
			Message:  "No vulnerabilities found (" + toolName + ")",
		}, nil
	}

	// Vulnerabilities found
	if hasVulnerabilities {
		// Extract a summary from the output
		summary := c.extractSummary(output, toolName)

		return CheckResult{
			ID:       c.ID(),
			Title:    c.Title(),
			Severity: SeverityWarn,
			Passed:   false,
			Message:  summary,
			Suggestions: []string{
				"Review and update vulnerable dependencies",
				"Run '" + toolName + "' for full details",
			},
		}, nil
	}

	// Command failed for other reasons
	return CheckResult{
		ID:       c.ID(),
		Title:    c.Title(),
		Severity: SeverityInfo,
		Passed:   true,
		Message:  toolName + " check inconclusive: " + strings.TrimSpace(output),
	}, nil
}

func (c VulnerabilityCheck) extractSummary(output, toolName string) string {
	lines := strings.Split(output, "\n")

	// Look for summary lines
	for _, line := range lines {
		lineLower := strings.ToLower(line)
		if strings.Contains(lineLower, "found") && strings.Contains(lineLower, "vulnerabilit") {
			return strings.TrimSpace(line)
		}
		if strings.Contains(lineLower, "total") && strings.Contains(lineLower, "vulnerabilit") {
			return strings.TrimSpace(line)
		}
	}

	// Count vulnerabilities mentioned
	outputLower := strings.ToLower(output)
	count := strings.Count(outputLower, "vulnerabilit")
	if count > 0 {
		return "Vulnerabilities found - review with " + toolName
	}

	return "Potential security issues found"
}

func fileExists(rootDir, relativePath string) bool {
	path := filepath.Join(rootDir, relativePath)
	_, err := os.Stat(path)
	return err == nil
}
